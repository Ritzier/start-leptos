---
source: tests/integration/basic.rs
expression: files_json
---
"{\n  \"Cargo.toml\": \"[workspace]\\nresolver = \\\"2\\\"\\nmembers = [\\\"app\\\", \\\"frontend\\\", \\\"server\\\"]\\n\\n[profile.wasm-release]\\ninherits = \\\"release\\\"\\ncodegen-units = 1\\nlto = true\\nopt-level = 'z'\\npanic = \\\"abort\\\"\\n\\n[workspace.dependencies]\\nleptos = { version = \\\"0.8\\\" }\\nleptos_meta = { version = \\\"0.8\\\" }\\nleptos_router = { version = \\\"0.8\\\" }\\nleptos_axum = { version = \\\"0.8\\\" }\\n\\n# WASM\\nwasm-bindgen = \\\"0.2\\\"\\n\\n# Server runtime\\naxum = \\\"0.8\\\"\\n\\n# Async runtime\\ntokio = { version = \\\"1\\\" }\\n\\n# Better error handling\\nthiserror = \\\"2\\\"\\n\\n# Logging\\nconsole_error_panic_hook = \\\"0.1\\\" # Better panic messages in browser console\\n\\n[[workspace.metadata.leptos]]\\nname = \\\"project-template\\\"\\noutput-name = \\\"project-template\\\"\\n\\nbin-package = \\\"server\\\"\\nlib-package = \\\"frontend\\\"\\n\\nstyle-file = \\\"style/main.scss\\\"\\n# tailwind-input-file = \\\"style/tailwind.css\\\"\\n\\nsite-root = \\\"target/site\\\"\\nsite-pkg-dir = \\\"pkg\\\"\\nassets-dir = \\\"public\\\"\\n\\nsite-addr = \\\"127.0.0.1:3000\\\"\\nreload-port = 3001\\n\\nend2end-cmd = \\\"npx playwright test\\\"\\nend2end-dir = \\\"end2end\\\"\\n\\nbrowserquery = \\\"defaults\\\"\\nenv = \\\"DEV\\\"\\nwatch = false\\n\\nbin-features = [\\\"ssr\\\"]\\nbin-default-features = false\\nlib-features = [\\\"hydrate\\\"]\\nlib-default-features = false\\nlib-profile-release = \\\"wasm-release\\\"\\n\",\n  \"app/Cargo.toml\": \"[package]\\nname = \\\"app\\\"\\nversion = \\\"0.1.0\\\"\\nedition = \\\"2024\\\"\\n\\n[dependencies]\\nleptos.workspace = true\\nleptos_meta.workspace = true\\nleptos_router.workspace = true\\nleptos_axum = { workspace = true, optional = true }\\n\\n[features]\\ndefault = []\\nhydrate = [\\\"leptos/hydrate\\\"]\\nssr = [\\\"leptos/ssr\\\", \\\"leptos_meta/ssr\\\", \\\"leptos_router/ssr\\\", \\\"dep:leptos_axum\\\"]\",\n  \"app/src/app.rs\": \"use leptos::prelude::*;\\nuse leptos_meta::provide_meta_context;\\nuse leptos_router::components::{Route, Router, Routes};\\nuse leptos_router::{Lazy, path};\\n\\nuse crate::pages::*;\\n\\n#[component]\\npub fn App() -> impl IntoView {\\n    provide_meta_context();\\n\\n    view! {\\n        <Router>\\n            <Routes fallback=|| \\\"Page not found\\\".into_view()>\\n                <Route path=path!(\\\"\\\") view={Lazy::<HomePage>::new()} />\\n            </Routes>\\n        </Router>\\n    }\\n}\\n\",\n  \"app/src/lib.rs\": \"mod pages;\\n\\nmod app;\\npub use app::App;\\n\\n#[cfg(feature = \\\"ssr\\\")]\\nmod shell;\\n#[cfg(feature = \\\"ssr\\\")]\\npub use shell::shell;\\n\",\n  \"app/src/pages/home.rs\": \"use leptos::prelude::*;\\nuse leptos_router::{LazyRoute, lazy_route};\\n\\npub struct HomePage;\\n\\n#[lazy_route]\\nimpl LazyRoute for HomePage {\\n    fn data() -> Self {\\n        Self\\n    }\\n\\n    fn view(_this: Self) -> AnyView {\\n        let (count, set_count) = signal(0);\\n        let on_click = move |_| set_count.update(|count| *count += 1);\\n\\n        view! {\\n            <h1>\\\"Welcome to Leptos!\\\"</h1>\\n            <button on:click=on_click>\\\"Click Me: \\\"{count}</button>\\n        }\\n        .into_any()\\n    }\\n}\\n\",\n  \"app/src/pages/mod.rs\": \"mod home;\\npub use home::HomePage;\\n\",\n  \"app/src/shell.rs\": \"use leptos::prelude::*;\\nuse leptos_meta::{Link, MetaTags, Stylesheet};\\n\\nuse crate::app::App;\\n\\npub fn shell(options: LeptosOptions) -> impl IntoView {\\n    view! {\\n        <!DOCTYPE html>\\n        <html lang=\\\"en\\\">\\n            <head>\\n                <meta charset=\\\"utf-8\\\" />\\n                <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />\\n                <AutoReload options=options.clone() />\\n                <HydrationScripts options />\\n                <Link rel=\\\"shortcut icon\\\" type_=\\\"image/ico\\\" href=\\\"/favicon.ico\\\" />\\n                <Stylesheet id=\\\"uno\\\" href=\\\"/uno.css\\\" />\\n                <MetaTags />\\n            </head>\\n            <body>\\n                <App />\\n            </body>\\n        </html>\\n    }\\n}\\n\",\n  \"frontend/Cargo.toml\": \"[package]\\nname = \\\"frontend\\\"\\nversion = \\\"0.1.0\\\"\\nedition = \\\"2024\\\"\\n\\n[lib]\\ncrate-type = [\\\"cdylib\\\", \\\"rlib\\\"]\\n\\n[dependencies]\\napp = { path = \\\"../app\\\", default-features = false }\\nleptos = { workspace = true }\\n\\nconsole_error_panic_hook.workspace = true\\nwasm-bindgen.workspace = true\\n\\n[features]\\ndefault = []\\nhydrate = [\\\"leptos/hydrate\\\", \\\"app/hydrate\\\"]\\n\",\n  \"frontend/src/lib.rs\": \"#[cfg(feature = \\\"hydrate\\\")]\\n#[wasm_bindgen::prelude::wasm_bindgen]\\npub fn hydrate() {\\n    use app::*;\\n\\n    console_error_panic_hook::set_once();\\n    leptos::mount::hydrate_lazy(App);\\n}\\n\",\n  \"package.json\": \"{\\n    \\\"devDependencies\\\": {\\n        \\\"unocss\\\": \\\"^66.5.5\\\"\\n    },\\n    \\\"scripts\\\": {\\n        \\\"watch\\\": \\\"unocss --watch\\\",\\n        \\\"build\\\": \\\"unocss --minify\\\"\\n    }\\n}\\n\",\n  \"public/favicon.ico\": \"binary\",\n  \"server/Cargo.toml\": \"[package]\\nname = \\\"server\\\"\\nversion = \\\"0.1.0\\\"\\nedition = \\\"2024\\\"\\n\\n[dependencies]\\napp = { path = \\\"../app\\\", default-features = false }\\nleptos_axum = { workspace = true, optional = true }\\nleptos_meta = { workspace = true, optional = true }\\nleptos_router = { workspace = true, optional = true }\\nleptos = { workspace = true }\\n\\n# Server runtime\\naxum = { workspace = true, optional = true }\\n\\n# Async runtime\\ntokio = { workspace = true, features = [\\n  \\\"rt-multi-thread\\\",\\n  \\\"signal\\\",\\n], optional = true }\\n\\n# Better error handling\\nthiserror = { workspace = true, optional = true }\\n\\n[features]\\ndefault = []\\nssr = [\\n  \\\"app/ssr\\\",\\n  \\\"dep:leptos_axum\\\",\\n  \\\"leptos_meta/ssr\\\",\\n  \\\"leptos_router/ssr\\\",\\n\\n  # Server runtime\\n  \\\"dep:axum\\\",\\n  \\\"dep:tokio\\\",\\n\\n  # Better error handling\\n  \\\"dep:thiserror\\\",\\n]\\n\",\n  \"server/src/debug.rs\": \"pub struct Env;\\n\\nimpl Env {\\n    pub async fn setup() {}\\n}\\n\",\n  \"server/src/errors.rs\": \"use std::net::SocketAddr;\\n\\nuse leptos::config::errors::LeptosConfigError;\\nuse thiserror::Error;\\n\\n#[derive(Debug, Error)]\\npub enum Error {\\n    #[error(\\\"LeptosConfig: {0}\\\")]\\n    LeptosConfig(#[from] LeptosConfigError),\\n\\n    #[error(\\\"{addr} Adress is used: {source}\\\")]\\n    AdressUsed {\\n        addr: SocketAddr,\\n        #[source]\\n        source: std::io::Error,\\n    },\\n\\n    #[error(\\\"Io: {0}\\\")]\\n    Io(#[from] std::io::Error),\\n}\\n\",\n  \"server/src/lib.rs\": \"#[cfg(feature = \\\"ssr\\\")]\\n#[cfg(debug_assertions)]\\nmod debug;\\n#[cfg(feature = \\\"ssr\\\")]\\nmod errors;\\n#[cfg(feature = \\\"ssr\\\")]\\nmod server;\\n\\n#[cfg(feature = \\\"ssr\\\")]\\n#[cfg(debug_assertions)]\\npub use debug::Env;\\n#[cfg(feature = \\\"ssr\\\")]\\npub use errors::Error;\\n#[cfg(feature = \\\"ssr\\\")]\\npub use server::Server;\\n\",\n  \"server/src/main.rs\": \"#[cfg(feature = \\\"ssr\\\")]\\n#[tokio::main]\\nasync fn main() -> Result<(), server::Error> {\\n    use server::*;\\n    use tokio::signal::unix::{SignalKind, signal};\\n\\n    #[cfg(debug_assertions)]\\n    Env::setup().await;\\n\\n    let mut sigint = signal(SignalKind::interrupt())?;\\n    let mut sigterm = signal(SignalKind::terminate())?;\\n\\n    tokio::select! {\\n        result = Server::setup() => {\\n            leptos::logging::error!(\\\"Server: {result:#?}\\\");\\n        }\\n\\n        _ = sigint.recv() => {\\n            leptos::logging::log!(\\\"Received SIGTINT\\\");\\n        }\\n\\n        _ = sigterm.recv() => {\\n            leptos::logging::log!(\\\"Received SIGTERM\\\");\\n        }\\n    }\\n\\n    Ok(())\\n}\\n\\n#[cfg(not(feature = \\\"ssr\\\"))]\\nfn main() {}\\n\",\n  \"server/src/server.rs\": \"use app::*;\\nuse axum::Router;\\nuse leptos::prelude::*;\\nuse leptos_axum::{LeptosRoutes, generate_route_list};\\n\\nuse crate::Error;\\n\\npub struct Server;\\n\\nimpl Server {\\n    pub async fn setup() -> Result<(), Error> {\\n        let conf = get_configuration(None)?;\\n        let addr = conf.leptos_options.site_addr;\\n        let leptos_options = conf.leptos_options;\\n        let routes = generate_route_list(App);\\n\\n        let app = Router::new()\\n            .leptos_routes(&leptos_options, routes, {\\n                let leptos_options = leptos_options.clone();\\n                move || shell(leptos_options.clone())\\n            })\\n            .fallback(leptos_axum::file_and_error_handler(shell))\\n            .with_state(leptos_options);\\n\\n        let listener = tokio::net::TcpListener::bind(&addr)\\n            .await\\n            .map_err(|e| Error::AdressUsed { addr, source: e })?;\\n\\n        axum::serve(listener, app.into_make_service())\\n            .await\\n            .map_err(|e| Error::AdressUsed { addr, source: e })?;\\n\\n        Ok(())\\n    }\\n}\\n\",\n  \"style/main.scss\": \"body {\\n    font-family: sans-serif;\\n    text-align: center;\\n}\\n\",\n  \"uno.config.ts\": \"import { defineConfig, presetMini } from \\\"unocss\\\";\\n\\nexport default defineConfig({\\n  cli: {\\n    entry: {\\n      patterns: [\\\"app/**/*.rs\\\"],\\n      outFile: \\\"public/uno.css\\\",\\n    },\\n  },\\n  presets: [presetMini()],\\n});\\n\"\n}"
